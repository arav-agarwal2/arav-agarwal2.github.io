{"componentChunkName":"component---src-templates-blog-post-js","path":"/EECS490/21/","result":{"data":{"site":{"siteMetadata":{"title":"Notes on Coffee, Books, and Programming"}},"markdownRemark":{"id":"16b451cc-66b1-5f5f-9f53-bea63e2858f6","excerpt":"Last Time: We started to talk about Rust. As a recap: Rust is an imperative language, so it has reference semantics with side effects on memory that we need to…","html":"<p>Last Time: We started to talk about Rust. As a recap:</p>\n<ul>\n<li>Rust is an imperative language, so it has reference semantics with side effects on memory that we need to worry about.</li>\n<li>Rust also has automatic memory management, where programmers did not need to have any explicit free for every memory allocation, which leads to memory safety.</li>\n<li>However, Rust manages to have this automatic memory management system in it’s static semantics rather than its dynamics semantics,  removing the need for a garbage collector and moving memory management into compile-time, making it speedy and correct!</li>\n</ul>\n<p>How? Rust manages to do this via the concept of ownership:</p>\n<ul>\n<li>The idea here is that every heap-allocated resource has an owner. So, if we had written <code class=\"language-text\">let x=String::from(&quot;hello&quot;)</code> , we say that <code class=\"language-text\">x</code> <strong>owns</strong> the resource in the heap that contains <code class=\"language-text\">hello</code>, and whatever else is needed to implement it.</li>\n<li>Then, when the owner dies ( which Rust defines as when “its lifetime ends” ), Rust will add a statement to deallocate the memory at <em>compile time.</em></li>\n<li>What makes this even more useful, however, is that Rust also checks for ownership semantics at compile time, so if a resource is deallocated, Rust will inform the user of that <strong>before the program is even run</strong>. This allows programmers to reason about memory management errors without needing to run <code class=\"language-text\">valgrind</code> or having to use a garbage collector.</li>\n</ul>\n<p>Now, with all of this power and this speed, we have to fundamentally change our understanding of memory to use it, as memory objects in Rust can <em>change owners</em>. What I mean is the following:</p>\n<ul>\n<li>When you write a statement like <code class=\"language-text\">let y = x</code> in many languages, this can actually do a number of things, depending on the language and its semantics. In C++, for example, y would have a copy of the value of x, and, in JavaScript, a language with many quirks, if x was an object then y would be a “shallow copy” of x, simply copying all of the values for the object, making all heap references refer to the exact pieces of memory as x. In Rust, unsurprisingly, assignment has an additional semantic to it: <strong>assignment moves ownership</strong>. So, in this case, <code class=\"language-text\">y</code> would own the String <code class=\"language-text\">hello</code>, and trying to get the value <code class=\"language-text\">hello</code> from x, say by calling <code class=\"language-text\">println!(&quot;{}!&quot;, x)</code> , would lead to a compiler error, as x does not own any heap allocated data at this point.</li>\n<li>Another case where Rust changes ownership is in function calls. If we write a function, say <code class=\"language-text\">lol(x)</code> , passing in <code class=\"language-text\">x</code> directly moves ownership of <code class=\"language-text\">x</code> into the calling function. Does, if we were to put the following code: <code class=\"language-text\">let x = String::from(&quot;h&quot;); lol(x); println!(&quot;{}!&quot;,x)</code> , then we’d also have a compiler error, as <code class=\"language-text\">lol</code> owned the string and finished its lifetime, deallocating x.</li>\n</ul>\n<p>Thus, while Rust is a clear example of how careful logic and reasoning can lead us to having better programming models that allow speed and logical clarity, we need to contend with this new concept of <code class=\"language-text\">ownership transfer</code>  to compensate. (This is really similar to how, by splitting up Haskell into a pure language and a command language to separate functional and imperative programming, we gain a feature, easy reasoning, we make writing our program slightly harder, as we have to understand the I/O Monad type and remember to structure our programs to make use of it, rather than allowing print statements everywhere like Python)</p>\n<p>So, how do users of Rust cope with what seems like deal-breakers? Through <strong>borrowing.</strong></p>\n<hr>\n<h3>Borrowing</h3>\n<p>In Rust, instead of creating functions that take in heap-allocated memory directly, we can create functions that take in heap-allocated string <strong>references</strong>. By doing so, Rust will not give ownership to the function; instead, it will allow the function to <strong>borrow</strong> ownership of the data allocated for the duration of the function, after which the owner transfers back to the original variable.  Thus, if we have the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">make_greeting</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>String<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token function\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">make_footer</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token function\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Sincerely, {}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cyrus\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token function\">make_greeting</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> footer <span class=\"token operator\">=</span> <span class=\"token function\">make_footer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This all works for a few reasons:</p>\n<ul>\n<li>Firstly, make<em>greeting and make</em>footer take in all of this data as references. Thus, they do not take ownership away from s at any point, allowing us to call functions on s as many times as we like.</li>\n<li>Secondly, format!, and other functions that end in <code class=\"language-text\">!</code> in Rust, are not really functions, but compiler macros. When the compiler encounters them, they simply replace these nicer functions with implementations that preserve ownership semantics (i.e. they take in references to s, so they simply borrow the data)</li>\n</ul>\n<p>Thus, we’re able to call functions multiple times and do fancy stuff, without explicitly needing to handle ownership at every point. Thanks Rust!</p>\n<p>With the recap over with, let’s go and get to the new content. We’ll cover some new material regarding references, Rust’s sum and product types, mutability and concurrency, and Rust’s lifetime system.</p>\n<hr>\n<h3>References, Redux</h3>\n<p>So, now that we believe we have the idea of references down, let’s test our understanding by trying to write a program in Rust. From our C++ perspective, it seems like the following code should work:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Dynamically allocate hello</span>\n  <span class=\"token operator\">&amp;</span>s <span class=\"token comment\">// Transfer a reference to this hello to the caller</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In C++, this sort of function should work, as we’re simply allocating some memory and returning it to us via a reference, where we’ll then use it and de-allocate it like responsible programmers. </p>\n<p>However, this actually results in a compiler error! Can you spot the problem?</p>\n<p>The problem here comes from the fact that <code class=\"language-text\">&amp;s</code> does not own <code class=\"language-text\">hello</code> ; it’s merely a reference to the data owned by <code class=\"language-text\">s</code> . As a result, when <code class=\"language-text\">s</code> dies, the memory associated with <code class=\"language-text\">&amp;s</code> dies, and so Rust complains, as the lifetime of <code class=\"language-text\">&amp;s</code> is larger than the owner, which would lead to a double free error. </p>\n<p>Thus, formally, there’s a rule we need to follow when it comes to (immutable) references in Rust:</p>\n<p>References can’t outlive the owner of the resource they refer to, to prevent double-free errors.</p>\n<p>Thus, while we can have resources borrowed by called functions, we cannot have those references outlive our owner, as that would lead to undeterminable behavior, something as language designers we strive to prevent.</p>\n<hr>\n<h3>The Product Type in Rust: Structs</h3>\n<p>In Rust, Structs serve as a product type. So, as an example, we could have a User struct:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">Struct User <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n   username<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n   email<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n   is_active<span class=\"token punctuation\">:</span> bool\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>and then create a User, in the following way:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> me <span class=\"token operator\">=</span> User <span class=\"token punctuation\">{</span>\n    username <span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar@umich.edu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    is_active<span class=\"token punctuation\">:</span> <span class=\"token keyword\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>As a side-note, structs must be defined before they can be created in Rust. If you’ve been through 370 by now, this is similar to C, where we need to have definitions before they are used. </p>\n<p>While this might seem like normal behavior for all languages, be aware that there are language where this is not the case. To see an example of such a ‘feature’, simply look up “JavaScript Hoisting” when you get a chance.</p>\n<p>In terms of owning heap-allocated data, structs in Rust <strong>own</strong> their fields. So, in this case, the variable <code class=\"language-text\">me</code> owns the dynamic data contained in the fields <code class=\"language-text\">username</code> and <code class=\"language-text\">email</code>, even if you need to write <code class=\"language-text\">me.username</code> and <code class=\"language-text\">[me.email](http://me.email)</code> to access the data.</p>\n<hr>\n<h3>The Sum Type in Rust: Enums</h3>\n<p>This is a quick aside by Cyrus. You can probably safely skip this</p>\n<p>Similarly, we could also define Sum Types in Rust, which are called “Enums”. </p>\n<p>We define them through the following syntax</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">enum</span> Bread <span class=\"token punctuation\">{</span> \n   White<span class=\"token punctuation\">,</span> Wheat<span class=\"token punctuation\">,</span> <span class=\"token function\">Multi</span><span class=\"token punctuation\">(</span>i32<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Thus, in this case, we simply have three types of Bread: White, Wheat, and Multi, which is a type constructor that needs a 32-bit integer to exist.</p>\n<p>We can also pattern match on these values, using the following syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">match</span> <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   White <span class=\"token operator\">=></span> <span class=\"token punctuation\">...</span> <span class=\"token punctuation\">,</span> Wheat <span class=\"token operator\">=></span> <span class=\"token punctuation\">...</span><span class=\"token punctuation\">,</span> <span class=\"token function\">Multi</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And, like Product Types above, the Sum Type owns any dynamically allocated data in it, so in this case if we had a name option type:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">enum</span> NameOpt <span class=\"token punctuation\">{</span>\n   Nil<span class=\"token punctuation\">,</span> <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> myName <span class=\"token operator\">=</span> NameOpt<span class=\"token punctuation\">::</span><span class=\"token function\">Some</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">::</span><span class=\"token function\">From</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Arav\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Then myName would own the String ‘Arav’.</p>\n<hr>\n<h3>Mutability: Part Deux</h3>\n<p>With these language features in mind, let’s return to mutability. So, if we remember, we need to use the <code class=\"language-text\">mut</code> keyword to declare an owner to a mutable value, and we also need to use <code class=\"language-text\">mut</code> to declare a mutable reference. </p>\n<p>When we have structs in Rust, then, we’ll need to make sure we have defined fields to be mutable, as fields can only be mutated in very specific ways. As an example, let’s say we had the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> me <span class=\"token operator\">=</span> User <span class=\"token punctuation\">{</span>\n    username <span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar@umich.edu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    is_active<span class=\"token punctuation\">:</span> <span class=\"token keyword\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>and then ran the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">me<span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cyrus\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will lead to a compiler error, as me is an immutable object because we haven’t used the <code class=\"language-text\">mut</code> keyword.</p>\n<p>However, if we did the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> me <span class=\"token operator\">=</span> User <span class=\"token punctuation\">{</span>\n    username <span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar@umich.edu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    is_active<span class=\"token punctuation\">:</span> <span class=\"token keyword\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nme<span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cyrus\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This now works, as the owner dictates that the data is mutable, and so we can mutate the fields accordingly. What happens here is that, when the username field points to new data, it drops the old field data, deallocating it, which makes sense, as we essentially force that data to have no owner.</p>\n<p>Now let’s say we have some mutable object, <code class=\"language-text\">me</code>, and try to run the following function:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>User<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   user<span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cyrus\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>where, as a side note, <code class=\"language-text\">user.username</code> is simply syntactic sugar for <code class=\"language-text\">(* user).username</code> , as that’s generally more readable.</p>\n<p>Well, believe it or not, but Rust complains yet again.</p>\n<p>This is simply because, although the owner is mutable, we only passed the data in through an immutable reference, <code class=\"language-text\">&amp;User</code> . If, instead, we used <code class=\"language-text\">&amp;mut User</code> , we’d get a mutable borrow of our data, allowing us to mutate the data again.</p>\n<p>While this does make sense from a purely syntactic viewpoint, the main reason why Rust enforces this constraint is so it can do some automatic parallelism for you. If two functions, <code class=\"language-text\">length(&amp;me)</code> and <code class=\"language-text\">user(&amp;me)</code> are ran next to each other, then we can schedule them concurrently without needing to worry about concurrency problems, speeding up your program!</p>\n<p>Now, while this  is all fine and dandy, there is one caveat added by adding mutable borrows to the language: </p>\n<hr>\n<p><strong>Rust only allows one live mutable borrow to exist any point in time and, if there’s a mutable borrow, there cannot be any immutable borrows. In fact, the owner itself can read or write while a mutable borrow is in action.</strong></p>\n<hr>\n<p>So, for example, the following code does not compile:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> me <span class=\"token operator\">=</span> User <span class=\"token punctuation\">{</span>\n    username <span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"comar@umich.edu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    is_active<span class=\"token punctuation\">:</span> <span class=\"token keyword\">false</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> me<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> me<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>me<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>As Rust recognizes that, if it tries to schedule any usage of <code class=\"language-text\">r</code> , <code class=\"language-text\">r2</code> , or <code class=\"language-text\">length</code> concurrently, then we’ll have problems, as those mutable borrows might influence the immutable borrow or each other, depending on how the CPU scheduler operates. (Though you can change this through a lock, or any other mutex operation).</p>\n<p>For more information about the CPU scheduler, and for a better understanding of why we need all of this in the first place, either take EECS 482, take EECS 482, or take EECS 482. If you’re impatient like me, then schedule yourself to take EECS482 next semester, AND also read “Operating Systems: Three Easy Pieces”, a set of lecture notes which goes into some really good descriptions on all of this. (It’s legally free through the instructor’s website!)</p>\n<p><a href=\"http://pages.cs.wisc.edu/~remzi/OSTEP/\">Operating Systems: Three Easy Pieces</a></p>\n<p>In this way, Rust keeps you from making the hardest of bugs happen,  concurrency-related bugs, with the minimal cost that you learn how to program with those issues in mind. In this manner, Rust  allows us to get the benefits of parallelism and concurrency, without the trouble that’s usually caused by it.</p>\n<hr>\n<h3>The Work of a Lifetime: Rust’s Lifetime System</h3>\n<p>We’ve been a bit careless about how Rust handles when objects die, only stating that it happens and, when it does, the memory associated with any heap-object owned by those objects gets deallocated from memory. Now, we’ll take a more careful look into how Rust actually handles lifetime. </p>\n<p>Originally, Rust had the lifetime of objects be simply the scope that they were defined in. Thus, variables exist only for the scope that something is defined in, an idea called <em>lexical scope:</em></p>\n<p><strong>Lexical Scope: The idea that, after a block, variables are deallocated.</strong></p>\n<p>Thus, if we had the following code in Rust:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">{</span> \n <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> me <span class=\"token operator\">=</span> User <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> me<span class=\"token punctuation\">;</span>\n <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>me<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>r2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then the second to last line would cause a compiler error, as <code class=\"language-text\">r</code>, as a mutable reference, is still alive, and we cannot have <code class=\"language-text\">r2</code>, an immutable reference, exist when <code class=\"language-text\">r</code> does. </p>\n<p>However, this is kinda annoying, as we just want to mutate me using r in <code class=\"language-text\">f(r)</code> , and so we need to do some work to change our idea of the code into reality, which can be annoying for simple tasks and potentially destructive for complex tasks.</p>\n<p>Thus, in order to cope with the annoyance, Rust has created so-called <code class=\"language-text\">Non-lexical lifetimes</code>  , where a variable’s lifetime ends at its last use. Thus, the code above works if you’re using Rust’s non-lexical lifetime , as <code class=\"language-text\">r</code> ’s last use is before any mention of <code class=\"language-text\">r2</code> , even if <code class=\"language-text\">r</code> is still in scope.</p>\n<p>This increases Rust’s flexibility, especially with short-lived mutable borrows.</p>","frontmatter":{"title":"Ownership and Borrowing in Rust 2 (EECS490Lec21)","date":"Mar 30, 2020 4:30 PM","description":"A Syntactic Boogaloo"}}},"pageContext":{"slug":"/EECS490/21/","previous":{"fields":{"slug":"/EECS490/20/"},"frontmatter":{"title":"Rust, and the Case of Memory Management (EECS490Lec20)"}},"next":null}}}