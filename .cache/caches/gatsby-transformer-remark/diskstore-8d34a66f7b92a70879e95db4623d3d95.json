{"expireTime":9007200846133797000,"key":"transformer-remark-markdown-ast-9210b42e1d8d678e827b22504a8916fb-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"So far, we’ve been assuming automatic memory management.","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":57,"offset":57},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":57,"offset":57},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If we have the following function:","position":{"start":{"line":4,"column":1,"offset":59},"end":{"line":4,"column":35,"offset":93},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":59},"end":{"line":4,"column":35,"offset":93},"indent":[]}},{"type":"html","lang":"ocaml","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\"><span class=\"token keyword\">let</span> f y <span class=\"token operator\">=</span> \n   <span class=\"token keyword\">let</span> counter <span class=\"token operator\">=</span> ref <span class=\"token number\">0</span> <span class=\"token keyword\">in</span>\n<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span>  \n <span class=\"token operator\">!</span>counter\n<span class=\"token keyword\">in</span> f <span class=\"token number\">3</span></code></pre></div>","position":{"start":{"line":6,"column":1,"offset":95},"end":{"line":15,"column":4,"offset":171},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So here, when counter is stops being used, (i.e. at the end, at !counter), the OCaml ","position":{"start":{"line":17,"column":1,"offset":173},"end":{"line":17,"column":86,"offset":258},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"garbage collector","position":{"start":{"line":17,"column":87,"offset":259},"end":{"line":17,"column":104,"offset":276},"indent":[]}}],"position":{"start":{"line":17,"column":86,"offset":258},"end":{"line":17,"column":105,"offset":277},"indent":[]}},{"type":"text","value":" deallocates that memory for another program to use automatically, making memory management easy, but less efficient than C/C++","position":{"start":{"line":17,"column":105,"offset":277},"end":{"line":17,"column":232,"offset":404},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":173},"end":{"line":17,"column":232,"offset":404},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Garbage Collector: A program that manages the references to memory a program uses, and allocates/deallocates the memory depending on what and how it’s currently being used.","position":{"start":{"line":19,"column":1,"offset":406},"end":{"line":19,"column":173,"offset":578},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":406},"end":{"line":19,"column":173,"offset":578},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"These programs have to be really clever and really sophisticated to work well, as they need to be able to handle a lot of strange scenarios, like the following:","position":{"start":{"line":21,"column":1,"offset":580},"end":{"line":21,"column":161,"offset":740},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":580},"end":{"line":21,"column":161,"offset":740},"indent":[]}},{"type":"html","lang":"ocaml","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\"><span class=\"token keyword\">let</span> f y <span class=\"token operator\">=</span> \n   <span class=\"token keyword\">let</span> counter <span class=\"token operator\">=</span> ref <span class=\"token number\">0</span>  <span class=\"token keyword\">in</span>\n <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  counter\n<span class=\"token keyword\">in</span> \n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> f y <span class=\"token keyword\">in</span>\n  <span class=\"token operator\">!</span>x</code></pre></div>","position":{"start":{"line":23,"column":1,"offset":742},"end":{"line":33,"column":4,"offset":838},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So here, we still can access the counter data, as we pass that data’s location into another variable. As a result, we need to not deallocate it, though if you had assumed references can’t go up a level in the stack that would have changed this function’s behavior. ","position":{"start":{"line":35,"column":1,"offset":840},"end":{"line":35,"column":266,"offset":1105},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":840},"end":{"line":35,"column":266,"offset":1105},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Besides this scenario, you also have many more scenarios. For example, references can be:","position":{"start":{"line":37,"column":1,"offset":1107},"end":{"line":37,"column":90,"offset":1196},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":1107},"end":{"line":37,"column":90,"offset":1196},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Bound to variables, like counter","position":{"start":{"line":39,"column":3,"offset":1200},"end":{"line":39,"column":35,"offset":1232},"indent":[]}}],"position":{"start":{"line":39,"column":3,"offset":1200},"end":{"line":39,"column":35,"offset":1232},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1198},"end":{"line":39,"column":35,"offset":1232},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Placed inside other data structures","position":{"start":{"line":40,"column":3,"offset":1235},"end":{"line":40,"column":38,"offset":1270},"indent":[]}}],"position":{"start":{"line":40,"column":3,"offset":1235},"end":{"line":40,"column":38,"offset":1270},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":1233},"end":{"line":40,"column":38,"offset":1270},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Returned from functions","position":{"start":{"line":41,"column":3,"offset":1273},"end":{"line":41,"column":26,"offset":1296},"indent":[]}}],"position":{"start":{"line":41,"column":3,"offset":1273},"end":{"line":41,"column":26,"offset":1296},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":1271},"end":{"line":41,"column":26,"offset":1296},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Bound to multiple variables","position":{"start":{"line":42,"column":3,"offset":1299},"end":{"line":42,"column":30,"offset":1326},"indent":[]}}],"position":{"start":{"line":42,"column":3,"offset":1299},"end":{"line":42,"column":30,"offset":1326},"indent":[]}}],"position":{"start":{"line":42,"column":1,"offset":1297},"end":{"line":42,"column":30,"offset":1326},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1198},"end":{"line":42,"column":30,"offset":1326},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"and so on. ","position":{"start":{"line":44,"column":1,"offset":1328},"end":{"line":44,"column":12,"offset":1339},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":1328},"end":{"line":44,"column":12,"offset":1339},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As you can see, Garbage Collection is a very complicated job, and thus cannot be done at compile time. Thus, OCaml, and other programs like it, uses a run-time garbage collector, which has to stop program execution every now and then to run these functions. It’s a very expensive operation, but it’s needed to maintain this abstraction.","position":{"start":{"line":46,"column":1,"offset":1341},"end":{"line":46,"column":337,"offset":1677},"indent":[]}}],"position":{"start":{"line":46,"column":1,"offset":1341},"end":{"line":46,"column":337,"offset":1677},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So while GC is safe, so it won’t have use after free bugs and double free bugs, it’s slowww","position":{"start":{"line":48,"column":1,"offset":1679},"end":{"line":48,"column":92,"offset":1770},"indent":[]}}],"position":{"start":{"line":48,"column":1,"offset":1679},"end":{"line":48,"column":92,"offset":1770},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Whereas, in C/C++, we have manual memory management, which is really cheap, but unsafe, via use after free bugs and double free bugs","position":{"start":{"line":50,"column":1,"offset":1772},"end":{"line":50,"column":133,"offset":1904},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":1772},"end":{"line":50,"column":133,"offset":1904},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":52,"column":1,"offset":1906},"end":{"line":52,"column":4,"offset":1909},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Can we do better?","position":{"start":{"line":54,"column":4,"offset":1914},"end":{"line":54,"column":21,"offset":1931},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":1911},"end":{"line":54,"column":21,"offset":1931},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So, for a while, we had this dichotomy between memory-safe, but garbage collected, languages and non memory-safe, but fast, languages. Enter Rust:","position":{"start":{"line":56,"column":1,"offset":1933},"end":{"line":56,"column":147,"offset":2079},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":1933},"end":{"line":56,"column":147,"offset":2079},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Rust is a memory-safe imperative language without manual memory management and no garbage collector","position":{"start":{"line":58,"column":1,"offset":2081},"end":{"line":58,"column":100,"offset":2180},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":2081},"end":{"line":58,"column":100,"offset":2180},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This makes it both safe and cheap, though it does complicate memory management to achieve this.","position":{"start":{"line":60,"column":1,"offset":2182},"end":{"line":60,"column":96,"offset":2277},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":2182},"end":{"line":60,"column":96,"offset":2277},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It’s also being used in a lot of places, from Firefox, to Dropbox, to Microsoft.","position":{"start":{"line":62,"column":1,"offset":2279},"end":{"line":62,"column":81,"offset":2359},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":2279},"end":{"line":62,"column":81,"offset":2359},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":64,"column":1,"offset":2361},"end":{"line":64,"column":4,"offset":2364},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Rust: Basic Principles","position":{"start":{"line":66,"column":4,"offset":2369},"end":{"line":66,"column":26,"offset":2391},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":2366},"end":{"line":66,"column":26,"offset":2391},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Before we learn what makes Rust tick, let’s go through and learn a bit of it beforehand.","position":{"start":{"line":68,"column":1,"offset":2393},"end":{"line":68,"column":89,"offset":2481},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":2393},"end":{"line":68,"column":89,"offset":2481},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Firstly, Rust is an expression oriented language:","position":{"start":{"line":70,"column":1,"offset":2483},"end":{"line":70,"column":50,"offset":2532},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":2483},"end":{"line":70,"column":50,"offset":2532},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\nx <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code></pre></div>","position":{"start":{"line":72,"column":1,"offset":2534},"end":{"line":75,"column":4,"offset":2562},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is an expression with type i32 and value b. ","position":{"start":{"line":77,"column":1,"offset":2564},"end":{"line":77,"column":50,"offset":2613},"indent":[]}}],"position":{"start":{"line":77,"column":1,"offset":2564},"end":{"line":77,"column":50,"offset":2613},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It also has all of the stuff we’re been talking about, and variables are given meaning through substitution like everything else we’ve been talking about. ","position":{"start":{"line":79,"column":1,"offset":2615},"end":{"line":79,"column":156,"offset":2770},"indent":[]}}],"position":{"start":{"line":79,"column":1,"offset":2615},"end":{"line":79,"column":156,"offset":2770},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Secondly, Rust distinguishes between stack and heap variables:","position":{"start":{"line":81,"column":1,"offset":2772},"end":{"line":81,"column":63,"offset":2834},"indent":[]}}],"position":{"start":{"line":81,"column":1,"offset":2772},"end":{"line":81,"column":63,"offset":2834},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For stack variables:","position":{"start":{"line":83,"column":1,"offset":2836},"end":{"line":83,"column":21,"offset":2856},"indent":[]}}],"position":{"start":{"line":83,"column":1,"offset":2836},"end":{"line":83,"column":21,"offset":2856},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// The let keyword defines a stack variable so:</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// On the stack</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// On the stack</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token comment\">// So even the following string is an immutable stack variable</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token comment\">// type: str ( with known size ) </span>\n<span class=\"token comment\">// As a result, we cannot concatenate strings directly:</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span> x<span class=\"token punctuation\">:</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">let</span> z <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">// INVALID, as we do not know the size of x+y at compile time</span>\n  z <span class=\"token comment\">// No explicit return as it's an expression oriented language</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","position":{"start":{"line":85,"column":1,"offset":2858},"end":{"line":98,"column":4,"offset":3327},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"For dynamic variables, you use constructors:","position":{"start":{"line":100,"column":1,"offset":3329},"end":{"line":100,"column":45,"offset":3373},"indent":[]}}],"position":{"start":{"line":100,"column":1,"offset":3329},"end":{"line":100,"column":45,"offset":3373},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// To make a heap-allocated string:</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//x:String</span></code></pre></div>","position":{"start":{"line":102,"column":1,"offset":3375},"end":{"line":105,"column":4,"offset":3464},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Thus, on the stack, x has the following structure:","position":{"start":{"line":107,"column":1,"offset":3466},"end":{"line":107,"column":51,"offset":3516},"indent":[]}}],"position":{"start":{"line":107,"column":1,"offset":3466},"end":{"line":107,"column":51,"offset":3516},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">x <span class=\"token punctuation\">-></span> <span class=\"token operator\">|</span>pointer to the actual heap memory<span class=\"token operator\">|</span> length \n     <span class=\"token operator\">|</span> <span class=\"token function\">capacity</span> <span class=\"token punctuation\">(</span>like vector grow from <span class=\"token number\">281</span><span class=\"token punctuation\">)</span></code></pre></div>","position":{"start":{"line":109,"column":1,"offset":3518},"end":{"line":112,"column":4,"offset":3622},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"But, on the heap, there’s the actual string contents. ","position":{"start":{"line":114,"column":1,"offset":3624},"end":{"line":114,"column":55,"offset":3678},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":3624},"end":{"line":114,"column":55,"offset":3678},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Again, this all makes sense, but how does Rust actually free heap-allocated memory without manual memory management or a garbage collector?","position":{"start":{"line":116,"column":1,"offset":3680},"end":{"line":116,"column":140,"offset":3819},"indent":[]}}],"position":{"start":{"line":116,"column":1,"offset":3680},"end":{"line":116,"column":140,"offset":3819},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":118,"column":1,"offset":3821},"end":{"line":118,"column":4,"offset":3824},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"How Rust free’s heap-allocated memory","position":{"start":{"line":120,"column":5,"offset":3830},"end":{"line":120,"column":42,"offset":3867},"indent":[]}}],"position":{"start":{"line":120,"column":1,"offset":3826},"end":{"line":120,"column":42,"offset":3867},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If we had the following code:","position":{"start":{"line":122,"column":1,"offset":3869},"end":{"line":122,"column":30,"offset":3898},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":3869},"end":{"line":122,"column":30,"offset":3898},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","position":{"start":{"line":124,"column":1,"offset":3900},"end":{"line":129,"column":4,"offset":3966},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here, Rust says that, as the variable becomes out-of-scope, it’ll get freed at the end of the scope, which it figures out at compile time through its lifetime static semantics system.","position":{"start":{"line":131,"column":1,"offset":3968},"end":{"line":131,"column":184,"offset":4151},"indent":[]}}],"position":{"start":{"line":131,"column":1,"offset":3968},"end":{"line":131,"column":184,"offset":4151},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Now that works and all, but let’s consider what would happen if we were to look at another example, assuming this is strictly how Rust works:","position":{"start":{"line":133,"column":1,"offset":4153},"end":{"line":133,"column":142,"offset":4294},"indent":[]}}],"position":{"start":{"line":133,"column":1,"offset":4153},"end":{"line":133,"column":142,"offset":4294},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","position":{"start":{"line":135,"column":1,"offset":4296},"end":{"line":144,"column":4,"offset":4395},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here, if we were to follow that simple strategy, we’d run into a problem. After we transfer the pointer value to y, as y goes out of scope, y’s data would be erased. However, as y’s data is x’s data, x’s data would be erased, and we would have a ","position":{"start":{"line":146,"column":1,"offset":4397},"end":{"line":146,"column":247,"offset":4643},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"use-after-free","position":{"start":{"line":146,"column":248,"offset":4644},"end":{"line":146,"column":262,"offset":4658},"indent":[]}}],"position":{"start":{"line":146,"column":247,"offset":4643},"end":{"line":146,"column":263,"offset":4659},"indent":[]}},{"type":"text","value":" bug in our system. ","position":{"start":{"line":146,"column":263,"offset":4659},"end":{"line":146,"column":283,"offset":4679},"indent":[]}}],"position":{"start":{"line":146,"column":1,"offset":4397},"end":{"line":146,"column":283,"offset":4679},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"However, what may be surprising here is that Rust calls the above program “illtyped” in its language, so the above program won’t even compile. How come? Rust adds a new concept called ownership to its type system, so in Rust:","position":{"start":{"line":148,"column":1,"offset":4681},"end":{"line":148,"column":226,"offset":4906},"indent":[]}}],"position":{"start":{"line":148,"column":1,"offset":4681},"end":{"line":148,"column":226,"offset":4906},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Every piece of Heap Data has a unique owner, which refers to the data that points to it. In our example, x was the original owner of this data.","position":{"start":{"line":150,"column":3,"offset":4910},"end":{"line":150,"column":146,"offset":5053},"indent":[]}}],"position":{"start":{"line":150,"column":3,"offset":4910},"end":{"line":150,"column":146,"offset":5053},"indent":[]}}],"position":{"start":{"line":150,"column":1,"offset":4908},"end":{"line":150,"column":146,"offset":5053},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Ownership can be transferred, so when we wrote ","position":{"start":{"line":151,"column":3,"offset":5056},"end":{"line":151,"column":50,"offset":5103},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">let y = x</code>","position":{"start":{"line":151,"column":50,"offset":5103},"end":{"line":151,"column":61,"offset":5114},"indent":[]}},{"type":"text","value":" , Rust moved the ownership of x from x to y, making y the unique owner ( and all of this is done statically! )","position":{"start":{"line":151,"column":61,"offset":5114},"end":{"line":151,"column":172,"offset":5225},"indent":[]}}],"position":{"start":{"line":151,"column":3,"offset":5056},"end":{"line":151,"column":172,"offset":5225},"indent":[]}}],"position":{"start":{"line":151,"column":1,"offset":5054},"end":{"line":151,"column":172,"offset":5225},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Deallocation occurs when the owner dies. Thus, after y goes out of scope, y’s heap data is freed, and so when x tries to print that data, we run into ill-typed, as x doesn’t own any data!","position":{"start":{"line":152,"column":3,"offset":5228},"end":{"line":152,"column":190,"offset":5415},"indent":[]}}],"position":{"start":{"line":152,"column":3,"offset":5228},"end":{"line":152,"column":190,"offset":5415},"indent":[]}}],"position":{"start":{"line":152,"column":1,"offset":5226},"end":{"line":152,"column":190,"offset":5415},"indent":[]}}],"position":{"start":{"line":150,"column":1,"offset":4908},"end":{"line":152,"column":190,"offset":5415},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Thus, even the following example is poorly-typed, as x isn’t the owner of the string anymore:","position":{"start":{"line":154,"column":1,"offset":5417},"end":{"line":154,"column":94,"offset":5510},"indent":[]}}],"position":{"start":{"line":154,"column":1,"offset":5417},"end":{"line":154,"column":94,"offset":5510},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//OK</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Not OK, as x is not the owner.</span></code></pre></div>","position":{"start":{"line":156,"column":1,"offset":5512},"end":{"line":161,"column":4,"offset":5644},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"With this concept, then, Rust is able to make all of the memory management calls compile-time bound, keeping memory management fast while still easy for basic uses.","position":{"start":{"line":163,"column":1,"offset":5646},"end":{"line":163,"column":165,"offset":5810},"indent":[]}}],"position":{"start":{"line":163,"column":1,"offset":5646},"end":{"line":163,"column":165,"offset":5810},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For simple immutable stack data, Rust has no sense of ownership. Thus, the following code works:","position":{"start":{"line":165,"column":1,"offset":5812},"end":{"line":165,"column":97,"offset":5908},"indent":[]}}],"position":{"start":{"line":165,"column":1,"offset":5812},"end":{"line":165,"column":97,"offset":5908},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// As x is a simple immutable, Rust just makes a copy</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// So this is still okay</span></code></pre></div>","position":{"start":{"line":167,"column":1,"offset":5910},"end":{"line":171,"column":4,"offset":6041},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Additionally, there are explicit methods to copy Heap variables:","position":{"start":{"line":173,"column":1,"offset":6043},"end":{"line":173,"column":65,"offset":6107},"indent":[]}}],"position":{"start":{"line":173,"column":1,"offset":6043},"end":{"line":173,"column":65,"offset":6107},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Copy of x, so we don't need to worry changing ownership</span></code></pre></div>","position":{"start":{"line":175,"column":1,"offset":6109},"end":{"line":178,"column":4,"offset":6229},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Now that we understand the central concept that makes Rust useful, ownership, let’s dig a bit deeper into how ownership transfers and how it changes hands.","position":{"start":{"line":180,"column":1,"offset":6231},"end":{"line":180,"column":156,"offset":6386},"indent":[]}}],"position":{"start":{"line":180,"column":1,"offset":6231},"end":{"line":180,"column":156,"offset":6386},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":182,"column":1,"offset":6388},"end":{"line":182,"column":4,"offset":6391},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Changing Hands: Rust Ownership Transfer","position":{"start":{"line":184,"column":4,"offset":6396},"end":{"line":184,"column":43,"offset":6435},"indent":[]}}],"position":{"start":{"line":184,"column":1,"offset":6393},"end":{"line":184,"column":43,"offset":6435},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Firstly, ownership is moved in and out of functions. If we had the following:","position":{"start":{"line":186,"column":1,"offset":6437},"end":{"line":186,"column":78,"offset":6514},"indent":[]}}],"position":{"start":{"line":186,"column":1,"offset":6437},"end":{"line":186,"column":78,"offset":6514},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span>String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\ns \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":188,"column":1,"offset":6516},"end":{"line":195,"column":4,"offset":6611},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"First, x transfers its ownership of Hello to identity’s s, as it transfers the ownership to the inner block. ","position":{"start":{"line":197,"column":1,"offset":6613},"end":{"line":197,"column":110,"offset":6722},"indent":[]}}],"position":{"start":{"line":197,"column":1,"offset":6613},"end":{"line":197,"column":110,"offset":6722},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Then, the identity function transfer’s its ownership to y, as y is assigned the reference value after identity is called.","position":{"start":{"line":199,"column":1,"offset":6724},"end":{"line":199,"column":122,"offset":6845},"indent":[]}}],"position":{"start":{"line":199,"column":1,"offset":6724},"end":{"line":199,"column":122,"offset":6845},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Thus, the following still works:","position":{"start":{"line":201,"column":1,"offset":6847},"end":{"line":201,"column":33,"offset":6879},"indent":[]}}],"position":{"start":{"line":201,"column":1,"offset":6847},"end":{"line":201,"column":33,"offset":6879},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":203,"column":1,"offset":6881},"end":{"line":205,"column":4,"offset":6912},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"But the following does not, as x transfers ownership to identity:","position":{"start":{"line":207,"column":1,"offset":6914},"end":{"line":207,"column":66,"offset":6979},"indent":[]}}],"position":{"start":{"line":207,"column":1,"offset":6914},"end":{"line":207,"column":66,"offset":6979},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":209,"column":1,"offset":6981},"end":{"line":211,"column":4,"offset":7012},"indent":[1,1]}},{"type":"thematicBreak","position":{"start":{"line":213,"column":1,"offset":7014},"end":{"line":213,"column":4,"offset":7017},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"While that’s nice conceptually, this does lead to a few new problems we have to consider when writing code. For example, consider the following code, assuming a length function ","position":{"start":{"line":215,"column":1,"offset":7019},"end":{"line":215,"column":178,"offset":7196},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">len : String -&gt; i32</code>","position":{"start":{"line":215,"column":178,"offset":7196},"end":{"line":215,"column":199,"offset":7217},"indent":[]}},{"type":"text","value":" :","position":{"start":{"line":215,"column":199,"offset":7217},"end":{"line":215,"column":201,"offset":7219},"indent":[]}}],"position":{"start":{"line":215,"column":1,"offset":7019},"end":{"line":215,"column":201,"offset":7219},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Whoops!</span></code></pre></div>","position":{"start":{"line":217,"column":1,"offset":7221},"end":{"line":221,"column":4,"offset":7309},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So we have a new problem; how do we call functions without transferring ownership to them, as we want to call length and other functions on Strings without needing to worry about ownership all of the time. ","position":{"start":{"line":223,"column":1,"offset":7311},"end":{"line":223,"column":207,"offset":7517},"indent":[]}}],"position":{"start":{"line":223,"column":1,"offset":7311},"end":{"line":223,"column":207,"offset":7517},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":225,"column":1,"offset":7519},"end":{"line":225,"column":4,"offset":7522},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"A First Attempt: Explicitly Moving the Resource in and Out","position":{"start":{"line":227,"column":5,"offset":7528},"end":{"line":227,"column":63,"offset":7586},"indent":[]}}],"position":{"start":{"line":227,"column":1,"offset":7524},"end":{"line":227,"column":63,"offset":7586},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Well, one thing we could do is we could simply redefine length to return both the length and the string itself:","position":{"start":{"line":229,"column":1,"offset":7588},"end":{"line":229,"column":112,"offset":7699},"indent":[]}}],"position":{"start":{"line":229,"column":1,"offset":7588},"end":{"line":229,"column":112,"offset":7699},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span>String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">..</span>\n  <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Move ownership to len, which moves it back to x.</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//OK, as we move the transfer back to x.</span></code></pre></div>","position":{"start":{"line":231,"column":1,"offset":7701},"end":{"line":240,"column":4,"offset":7915},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"However, this has the downside of complicating our functions, and it can lead to potentially a function taking 8 things returning 8 or more things ( which can happen in systems level code )","position":{"start":{"line":242,"column":1,"offset":7917},"end":{"line":242,"column":190,"offset":8106},"indent":[]}}],"position":{"start":{"line":242,"column":1,"offset":7917},"end":{"line":242,"column":190,"offset":8106},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Obviously, as Rust is so used, this can’t be how Rust does it; no one would want to work in it.","position":{"start":{"line":244,"column":1,"offset":8108},"end":{"line":244,"column":96,"offset":8203},"indent":[]}}],"position":{"start":{"line":244,"column":1,"offset":8108},"end":{"line":244,"column":96,"offset":8203},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":246,"column":1,"offset":8205},"end":{"line":246,"column":4,"offset":8208},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"A Second Attempt : Borrowing","position":{"start":{"line":248,"column":5,"offset":8214},"end":{"line":248,"column":33,"offset":8242},"indent":[]}}],"position":{"start":{"line":248,"column":1,"offset":8210},"end":{"line":248,"column":33,"offset":8242},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So, what if instead of passing the string itself as an argument, what if we passed a reference to the string as an argument? Well, it turns out by doing this, Rust does not transfer ownership to the calling function. Therefore, we’re able to let a function “borrow” our string resource, compute its value, and transfer ownership back to us:","position":{"start":{"line":250,"column":1,"offset":8244},"end":{"line":250,"column":341,"offset":8584},"indent":[]}}],"position":{"start":{"line":250,"column":1,"offset":8244},"end":{"line":250,"column":341,"offset":8584},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">len</span> <span class=\"token punctuation\">(</span>s <span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token punctuation\">...</span>\n   n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Thus, x is still the owner, but len borrows access</span></code></pre></div>","position":{"start":{"line":252,"column":1,"offset":8586},"end":{"line":259,"column":4,"offset":8736},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is how Rust generally works with data when dealing with immutable functions, but what about mutable functions / methods?","position":{"start":{"line":261,"column":1,"offset":8738},"end":{"line":261,"column":126,"offset":8863},"indent":[]}}],"position":{"start":{"line":261,"column":1,"offset":8738},"end":{"line":261,"column":126,"offset":8863},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":263,"column":1,"offset":8865},"end":{"line":263,"column":4,"offset":8868},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Mutability in Rust","position":{"start":{"line":265,"column":5,"offset":8874},"end":{"line":265,"column":23,"offset":8892},"indent":[]}}],"position":{"start":{"line":265,"column":1,"offset":8870},"end":{"line":265,"column":23,"offset":8892},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Say we wish to follow the time-honored tradition of programmers and write the following Hello World program:","position":{"start":{"line":267,"column":1,"offset":8894},"end":{"line":267,"column":109,"offset":9002},"indent":[]}}],"position":{"start":{"line":267,"column":1,"offset":8894},"end":{"line":267,"column":109,"offset":9002},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//OOF</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>","position":{"start":{"line":269,"column":1,"offset":9004},"end":{"line":273,"column":4,"offset":9096},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If we were to compile this program, the second line will cause a compilation error, as we haven’t told Rust we want our data to be mutable. Thus, for a variable to be mutable, and for us to have a mutable piece of data, we need to add the ","position":{"start":{"line":275,"column":1,"offset":9098},"end":{"line":275,"column":240,"offset":9337},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">mut</code>","position":{"start":{"line":275,"column":240,"offset":9337},"end":{"line":275,"column":245,"offset":9342},"indent":[]}},{"type":"text","value":" keyword:","position":{"start":{"line":275,"column":245,"offset":9342},"end":{"line":275,"column":254,"offset":9351},"indent":[]}}],"position":{"start":{"line":275,"column":1,"offset":9098},"end":{"line":275,"column":254,"offset":9351},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//All good, so we mutate in place. </span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}!\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>","position":{"start":{"line":277,"column":1,"offset":9353},"end":{"line":281,"column":4,"offset":9479},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Now, let’s say we had a function, f, which edits a string in place, and we wanted to use it with a reference. We can’t do the following:","position":{"start":{"line":283,"column":1,"offset":9481},"end":{"line":283,"column":137,"offset":9617},"indent":[]}}],"position":{"start":{"line":283,"column":1,"offset":9481},"end":{"line":283,"column":137,"offset":9617},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":285,"column":1,"offset":9619},"end":{"line":288,"column":4,"offset":9672},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is because ","position":{"start":{"line":290,"column":1,"offset":9674},"end":{"line":290,"column":17,"offset":9690},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">&amp;x</code>","position":{"start":{"line":290,"column":17,"offset":9690},"end":{"line":290,"column":21,"offset":9694},"indent":[]}},{"type":"text","value":" creates a static, or immutable, reference to x in Rust. To make it mutable, we need to add the mut keyword again:","position":{"start":{"line":290,"column":21,"offset":9694},"end":{"line":290,"column":135,"offset":9808},"indent":[]}}],"position":{"start":{"line":290,"column":1,"offset":9674},"end":{"line":290,"column":135,"offset":9808},"indent":[]}},{"type":"html","lang":"rust","meta":null,"value":"<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> x <span class=\"token operator\">=</span> String<span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span> <span class=\"token keyword\">mut</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","position":{"start":{"line":292,"column":1,"offset":9810},"end":{"line":295,"column":4,"offset":9868},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That allows us to mutate the data in the inner function, and thus use our new heap data in all the ways we’d want to for most projects.","position":{"start":{"line":297,"column":1,"offset":9870},"end":{"line":297,"column":136,"offset":10005},"indent":[]}}],"position":{"start":{"line":297,"column":1,"offset":9870},"end":{"line":297,"column":136,"offset":10005},"indent":[]}},{"type":"thematicBreak","position":{"start":{"line":299,"column":1,"offset":10007},"end":{"line":299,"column":4,"offset":10010},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Summary","position":{"start":{"line":301,"column":3,"offset":10014},"end":{"line":301,"column":10,"offset":10021},"indent":[]}}],"position":{"start":{"line":301,"column":1,"offset":10012},"end":{"line":301,"column":10,"offset":10021},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Rust manages to not have explicit memory management AND not have a garbage collector by introducing a new concept: the owner","position":{"start":{"line":303,"column":3,"offset":10025},"end":{"line":303,"column":127,"offset":10149},"indent":[]}}],"position":{"start":{"line":303,"column":3,"offset":10025},"end":{"line":303,"column":127,"offset":10149},"indent":[]}}],"position":{"start":{"line":303,"column":1,"offset":10023},"end":{"line":303,"column":127,"offset":10149},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Each piece of heap data has a unique owner, and frees when its owner dies","position":{"start":{"line":304,"column":3,"offset":10152},"end":{"line":304,"column":76,"offset":10225},"indent":[]}}],"position":{"start":{"line":304,"column":3,"offset":10152},"end":{"line":304,"column":76,"offset":10225},"indent":[]}}],"position":{"start":{"line":304,"column":1,"offset":10150},"end":{"line":304,"column":76,"offset":10225},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Through borrowing and the ","position":{"start":{"line":305,"column":3,"offset":10228},"end":{"line":305,"column":29,"offset":10254},"indent":[]}},{"type":"html","value":"<code class=\"language-text\">mut</code>","position":{"start":{"line":305,"column":29,"offset":10254},"end":{"line":305,"column":34,"offset":10259},"indent":[]}},{"type":"text","value":" keyword, we can have owners share resourced with functions without transferring ownership, allowing for usage like RAII in C++.","position":{"start":{"line":305,"column":34,"offset":10259},"end":{"line":305,"column":162,"offset":10387},"indent":[]}}],"position":{"start":{"line":305,"column":3,"offset":10228},"end":{"line":305,"column":162,"offset":10387},"indent":[]}}],"position":{"start":{"line":305,"column":1,"offset":10226},"end":{"line":305,"column":162,"offset":10387},"indent":[]}}],"position":{"start":{"line":303,"column":1,"offset":10023},"end":{"line":305,"column":162,"offset":10387},"indent":[1,1]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":305,"column":162,"offset":10387}}}}